A. SOLID DocumentationThis project is built with the SOLID design principles to ensure maintainability and scalability.Single Responsibility Principle (SRP): Each class has one reason to change. For example, [ClassName]Service handles business logic, while [ClassName]Repository is strictly for database operations.Open/Closed Principle (OCP): We used inheritance and interfaces so the system is open for extension but closed for modification. New [Features/Types] can be added by extending the [BaseClass] without altering existing code.Liskov Substitution Principle (LSP): Subclasses like [ChildClass] can replace instances of [BaseClass] without breaking the application, ensuring consistent behavior across the hierarchy.Interface Segregation Principle (ISP): Instead of one "fat" interface, we used narrow interfaces like [InterfaceA] and [InterfaceB], so classes only implement methods they actually use.Dependency Inversion Principle (DIP): High-level modules do not depend on low-level modules. We used Constructor Injection to inject interfaces (e.g., IRepository) into our Services.B. Advanced OOP FeaturesGenerics: Used in [GenericClassName<T>] to create reusable data structures that work with any object type while maintaining type safety.Lambdas: Employed within the Stream API to filter and sort lists (e.g., list.stream().filter(item -> ...)).Reflection: Used in the [ReflectionUtil] class to inspect object fields at runtime and automate [Task, e.g., table generation].Interface Methods: Utilized default methods for shared logic and static methods for utility functions within interfaces.C. OOP DocumentationAbstract Classes: [AbstractClassName] provides a template for [Subclass1] and [Subclass2].Composition: The [ClassA] class contains an instance of [ClassB], representing a "has-a" relationship.Polymorphism: Demonstrated by calling calculate() on a list of [BaseClass] objects, where each subclass provides its own implementation.UML DiagramNote: Replace the link below with your actual image path.D. Database SectionSchema & ConstraintsSQLCREATE TABLE users (
    id SERIAL PRIMARY KEY,
    username VARCHAR(50) NOT NULL UNIQUE,
    email VARCHAR(100) CHECK (email LIKE '%@%')
);
-- Add other tables here
Sample InsertsSQLINSERT INTO users (username, email) VALUES ('Zhanbol', 'zhanbol@example.com');
E. Architecture ExplanationWe follow a layered architecture:Controller: Handles incoming requests and returns responses.Service: Contains the core business logic and calls the Repository.Repository: Directly interacts with the database (PostgreSQL/MySQL).Example Request Flow:Client Request -> Controller.create() -> Service.validate() -> Repository.save() -> Database.F. Execution InstructionsRequirementsJava Version: 17 or higherDatabase: [PostgreSQL/MySQL]Dependencies: [e.g., JDBC Driver]How to RunClone the repository.Configure your DB credentials in db.properties or Config.java.Compile: javac Main.javaRun: java MainG. ScreenshotsFeatureScreenshotSuccessful CRUDValidation FailuresReflection OutputLambda SortingH. ReflectionWhat I learned: I gained a deep understanding of how interfaces decouple code and how Reflection allows for "meta-programming."Challenges: Implementing DIP was tricky initially, especially managing the lifecycle of dependencies without a framework like Spring.Value of SOLID: SOLID architecture makes the code much easier to debug. When a bug occurs, I know exactly which "single responsibility" class to look at.

